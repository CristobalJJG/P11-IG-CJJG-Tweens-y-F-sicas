<html lang="en">

<head>
    <title>Convex object breaking example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            color: #333;
        }
    </style>
</head>

<body>

    <div id="info">Physics threejs demo with convex objects breaking in real time<br />Press mouse to throw balls and move the camera.</div>
    <div id="container"></div>

    <script src="js/libs/ammo.wasm.js"></script>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script async src="./ConvexObjectBreaker.js"></script>
    <script async src="./ConvexGeometry.js"></script>

    <script type="module">const raycaster = new THREE.Raycaster(); const ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } ); // Physics variables const gravityConstant = 7.8; let collisionConfiguration; let dispatcher; let broadphase; let solver; let physicsWorld;
        const margin = 0.05; const convexBreaker = new ConvexObjectBreaker(); // Rigid bodies include all movable objects const rigidBodies = []; const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); let transformAux1; let tempBtVec3_1;
        const objectsToRemove = []; for ( let i = 0; i
        < 500; i ++ ) { objectsToRemove[ i ]=n ull; } let numObjectsToRemove=0 ; const impactPoint=n ew THREE.Vector3(); const impactNormal=n ew THREE.Vector3(); // - Main code - Ammo().then( function ( AmmoLib ) { Ammo=A mmoLib; init(); animate(); } ); // -
            Functions - function init() { initGraphics(); initPhysics(); createObjects(); initInput(); } function initGraphics() { container=d ocument.getElementById( 'container' ); camera=n ew THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight,
            0.2, 2000 ); scene=n ew THREE.Scene(); scene.background=n ew THREE.Color( 0xbfd1e5 ); camera.position.set( - 14, 8, 16 ); renderer=n ew THREE.WebGLRenderer(); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( window.innerWidth,
            window.innerHeight ); renderer.shadowMap.enabled=t rue; container.appendChild( renderer.domElement ); controls=n ew OrbitControls( camera, renderer.domElement ); controls.target.set( 0, 2, 0 ); controls.update(); textureLoader=n ew THREE.TextureLoader();
            const ambientLight=n ew THREE.AmbientLight( 0x707070 ); scene.add( ambientLight ); const light=n ew THREE.DirectionalLight( 0xffffff, 1 ); light.position.set( - 10, 18, 5 ); light.castShadow=t rue; const d=1 4; light.shadow.camera.left=- d; light.shadow.camera.right=d
            ; light.shadow.camera.top=d ; light.shadow.camera.bottom=- d; light.shadow.camera.near=2 ; light.shadow.camera.far=5 0; light.shadow.mapSize.x=1 024; light.shadow.mapSize.y=1 024; scene.add( light ); stats=n ew Stats(); stats.domElement.style.position='absolute'
            ; stats.domElement.style.top='0px' ; container.appendChild( stats.domElement ); // window.addEventListener( 'resize', onWindowResize ); } function initPhysics() { // Physics configuration collisionConfiguration=n ew Ammo.btDefaultCollisionConfiguration();
            dispatcher=n ew Ammo.btCollisionDispatcher( collisionConfiguration ); broadphase=n ew Ammo.btDbvtBroadphase(); solver=n ew Ammo.btSequentialImpulseConstraintSolver(); physicsWorld=n ew Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver,
            collisionConfiguration ); physicsWorld.setGravity( new Ammo.btVector3( 0, - gravityConstant, 0 ) ); transformAux1=n ew Ammo.btTransform(); tempBtVec3_1=n ew Ammo.btVector3( 0, 0, 0 ); } function createObject( mass, halfExtents, pos, quat, material
            ) { const object=n ew THREE.Mesh( new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 ), material ); object.position.copy( pos ); object.quaternion.copy( quat ); convexBreaker.prepareBreakableObject( object, mass, new
            THREE.Vector3(), new THREE.Vector3(), true ); createDebrisFromBreakableObject( object ); } function createObjects() { // Ground pos.set( 0, - 0.5, 0 ); quat.set( 0, 0, 0, 1 ); const ground=c reateParalellepipedWithPhysics( 40, 1, 40, 0, pos, quat,
            new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) ); ground.receiveShadow=t rue; textureLoader.load( 'textures/grid.png', function ( texture ) { texture.wrapS=T HREE.RepeatWrapping; texture.wrapT=T HREE.RepeatWrapping; texture.repeat.set( 40,
            40 ); ground.material.map=t exture; ground.material.needsUpdate=t rue; } ); // Tower 1 const towerMass=1 000; const towerHalfExtents=n ew THREE.Vector3( 2, 5, 2 ); pos.set( - 8, 5, 0 ); quat.set( 0, 0, 0, 1 ); createObject( towerMass, towerHalfExtents,
            pos, quat, createMaterial( 0xB03014 ) ); // Tower 2 pos.set( 8, 5, 0 ); quat.set( 0, 0, 0, 1 ); createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03214 ) ); //Bridge const bridgeMass=1 00; const bridgeHalfExtents=n ew THREE.Vector3(
            7, 0.2, 1.5 ); pos.set( 0, 10.2, 0 ); quat.set( 0, 0, 0, 1 ); createObject( bridgeMass, bridgeHalfExtents, pos, quat, createMaterial( 0xB3B865 ) ); // Stones const stoneMass=1 20; const stoneHalfExtents=n ew THREE.Vector3( 1, 2, 0.15 ); const
            numStones=8 ; quat.set( 0, 0, 0, 1 ); for ( let i=0 ; i < numStones; i ++ ) { pos.set( 0, 2, 15 * ( 0.5 - i / ( numStones + 1 ) ) ); createObject( stoneMass, stoneHalfExtents, pos, quat, createMaterial( 0xB0B0B0 ) ); } // Mountain const mountainMass=8
            60; const mountainHalfExtents=n ew THREE.Vector3( 4, 5, 4 ); pos.set( 5, mountainHalfExtents.y * 0.5, - 7 ); quat.set( 0, 0, 0, 1 ); const mountainPoints=[ ]; mountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y,
            mountainHalfExtents.z ) ); mountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z ) ); mountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z
            ) ); mountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z ) ); mountainPoints.push( new THREE.Vector3( 0, mountainHalfExtents.y, 0 ) ); const mountain=n ew THREE.Mesh( new ConvexGeometry(
            mountainPoints ), createMaterial( 0xB03814 ) ); mountain.position.copy( pos ); mountain.quaternion.copy( quat ); convexBreaker.prepareBreakableObject( mountain, mountainMass, new THREE.Vector3(), new THREE.Vector3(), true ); createDebrisFromBreakableObject(
            mountain ); } function createParalellepipedWithPhysics( sx, sy, sz, mass, pos, quat, material ) { const object=n ew THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material ); const shape=n ew Ammo.btBoxShape( new Ammo.btVector3( sx
            * 0.5, sy * 0.5, sz * 0.5 ) ); shape.setMargin( margin ); createRigidBody( object, shape, mass, pos, quat ); return object; } function createDebrisFromBreakableObject( object ) { object.castShadow=t rue; object.receiveShadow=t rue; const shape=c
            reateConvexHullPhysicsShape( object.geometry.attributes.position.array ); shape.setMargin( margin ); const body=c reateRigidBody( object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity ); //
            Set pointer back to the three object only in the debris objects const btVecUserData=n ew Ammo.btVector3( 0, 0, 0 ); btVecUserData.threeObject=o bject; body.setUserPointer( btVecUserData ); } function removeDebris( object ) { scene.remove( object
            ); physicsWorld.removeRigidBody( object.userData.physicsBody ); } function createConvexHullPhysicsShape( coords ) { const shape=n ew Ammo.btConvexHullShape(); for ( let i=0 , il=c oords.length; i < il; i +=3 ) { tempBtVec3_1.setValue( coords[
            i ], coords[ i + 1 ], coords[ i + 2 ] ); const lastOne=( i>= ( il - 3 ) ); shape.addPoint( tempBtVec3_1, lastOne ); } return shape; } function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) { if ( pos ) { object.position.copy( pos ); } else { pos = object.position; } if ( quat )
            { object.quaternion.copy( quat ); } else { quat = object.quaternion; } const transform = new Ammo.btTransform(); transform.setIdentity(); transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) ); transform.setRotation( new Ammo.btQuaternion(
            quat.x, quat.y, quat.z, quat.w ) ); const motionState = new Ammo.btDefaultMotionState( transform ); const localInertia = new Ammo.btVector3( 0, 0, 0 ); physicsShape.calculateLocalInertia( mass, localInertia ); const rbInfo = new Ammo.btRigidBodyConstructionInfo(
            mass, motionState, physicsShape, localInertia ); const body = new Ammo.btRigidBody( rbInfo ); body.setFriction( 0.5 ); if ( vel ) { body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) ); } if ( angVel ) { body.setAngularVelocity(
            new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) ); } object.userData.physicsBody = body; object.userData.collided = false; scene.add( object ); if ( mass > 0 ) { rigidBodies.push( object ); // Disable deactivation body.setActivationState(
            4 ); } physicsWorld.addRigidBody( body ); return body; } function createRandomColor() { return Math.floor( Math.random() * ( 1
            << 24 ) ); } function createMaterial( color ) { color=c olor || createRandomColor(); return new THREE.MeshPhongMaterial( { color: color } ); } function initInput() { window.addEventListener( 'pointerdown', function ( event ) { mouseCoords.set( ( event.clientX
            / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 ); raycaster.setFromCamera( mouseCoords, camera ); // Creates a ball and throws it const ballMass=3 5; const ballRadius=0 .4; const ball=n ew THREE.Mesh( new THREE.SphereGeometry(
                ballRadius, 14, 10 ), ballMaterial ); ball.castShadow=t rue; ball.receiveShadow=t rue; const ballShape=n ew Ammo.btSphereShape( ballRadius ); ballShape.setMargin( margin ); pos.copy( raycaster.ray.direction ); pos.add( raycaster.ray.origin
                ); quat.set( 0, 0, 0, 1 ); const ballBody=c reateRigidBody( ball, ballShape, ballMass, pos, quat ); pos.copy( raycaster.ray.direction ); pos.multiplyScalar( 24 ); ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) ); } );
                } function onWindowResize() { camera.aspect=w indow.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); } function animate() { requestAnimationFrame( animate ); render();
                stats.update(); } function render() { const deltaTime=c lock.getDelta(); updatePhysics( deltaTime ); renderer.render( scene, camera ); } function updatePhysics( deltaTime ) { // Step world physicsWorld.stepSimulation( deltaTime, 10 ); // Update
                rigid bodies for ( let i=0 , il=r igidBodies.length; i < il; i ++ ) { const objThree=r igidBodies[ i ]; const objPhys=o bjThree.userData.physicsBody; const ms=o bjPhys.getMotionState(); if ( ms ) { ms.getWorldTransform( transformAux1 ); const
                p=t ransformAux1.getOrigin(); const q=t ransformAux1.getRotation(); objThree.position.set( p.x(), p.y(), p.z() ); objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() ); objThree.userData.collided=f alse; } } for ( let i=0 , il=d ispatcher.getNumManifolds();
                i < il; i ++ ) { const contactManifold=d ispatcher.getManifoldByIndexInternal( i ); const rb0=A mmo.castObject( contactManifold.getBody0(), Ammo.btRigidBody ); const rb1=A mmo.castObject( contactManifold.getBody1(), Ammo.btRigidBody ); const
                threeObject0=A mmo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject; const threeObject1=A mmo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject; if ( ! threeObject0 && ! threeObject1 ) { continue; } const userData0=t
                hreeObject0 ? threeObject0.userData : null; const userData1=t hreeObject1 ? threeObject1.userData : null; const breakable0=u serData0 ? userData0.breakable : false; const breakable1=u serData1 ? userData1.breakable : false; const collided0=u
                serData0 ? userData0.collided : false; const collided1=u serData1 ? userData1.collided : false; if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) { continue; } let contact=f alse; let maxImpulse=0 ; for ( let j=0 , jl=c
                ontactManifold.getNumContacts(); j < jl; j ++ ) { const contactPoint=c ontactManifold.getContactPoint( j ); if ( contactPoint.getDistance() < 0 ) { contact=t rue; const impulse=c ontactPoint.getAppliedImpulse(); if ( impulse> maxImpulse ) { maxImpulse = impulse; const pos = contactPoint.get_m_positionWorldOnB(); const normal = contactPoint.get_m_normalWorldOnB(); impactPoint.set( pos.x(), pos.y(), pos.z() ); impactNormal.set( normal.x(), normal.y(), normal.z()
                ); } break; } } // If no point has contact, abort if ( ! contact ) continue; // Subdivision const fractureImpulse = 250; if ( breakable0 && ! collided0 && maxImpulse > fractureImpulse ) { const debris = convexBreaker.subdivideByImpact(
                threeObject0, impactPoint, impactNormal, 1, 2, 1.5 ); const numObjects = debris.length; for ( let j = 0; j
                < numObjects; j ++ ) { const vel=r b0.getLinearVelocity(); const angVel=r b0.getAngularVelocity(); const fragment=d ebris[ j ]; fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() ); fragment.userData.angularVelocity.set( angVel.x(), angVel.y(),
                    angVel.z() ); createDebrisFromBreakableObject( fragment ); } objectsToRemove[ numObjectsToRemove ++ ]=t hreeObject0; userData0.collided=t rue; } if ( breakable1 && ! collided1 && maxImpulse> fractureImpulse ) { const debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal, 1, 2, 1.5 ); const numObjects = debris.length; for ( let j = 0; j
                    < numObjects; j ++ ) { const vel=r b1.getLinearVelocity(); const angVel=r b1.getAngularVelocity(); const fragment=d ebris[ j ]; fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() ); fragment.userData.angularVelocity.set( angVel.x(), angVel.y(),
                        angVel.z() ); createDebrisFromBreakableObject( fragment ); } objectsToRemove[ numObjectsToRemove ++ ]=t hreeObject1; userData1.collided=t rue; } } for ( let i=0 ; i < numObjectsToRemove; i ++ ) { removeDebris( objectsToRemove[ i ]
                        ); } numObjectsToRemove=0 ; } </script>

</body>

</html>